// * ***********************************************************************
// *
// *   PRE-SETUP
// *
// *************************************************************************

document.write('<canvas id="canvas" width="' + (window.innerWidth) + '" height="' + (window.innerHeight) + '"> \
  <h1> Canvas doesn\'t seem to be working! </h1> \
</canvas>');

// * ***********************************************************************
// *
// *   CONSTANTS
// *   define any global constants here
// *
// *************************************************************************


// * ***********************************************************************
// *
// *   HELPER FUNCTIONS
// *   define any global helper functions here
// *
// *************************************************************************

const radians = (degrees) => (Math.PI / 180) * degrees;

// * ***********************************************************************
// *
// *   DOCUMENT READY
// *
// *************************************************************************

$(document).ready(() => {


  // * ***********************************************************************
  // *
  // *  ELEMENTS CLASS
  // *  Holds references to any elements used
  // *
  // *************************************************************************
  class Elements {
    constructor() {
      this.canvas = $('#canvas')[0];
      this.ctx = this.canvas.getContext('2d');
    }
  }

  const elems = new Elements();

  // * ***********************************************************************
  // *
  // *  DIMENSIONS CLASS
  // *  Hold references to any dimensions used in calculations and
  // *  recalculate as needed (e.g. on window resize)
  // *
  // *************************************************************************
  class Dimensions {
    constructor() {
      //set the dimensions on load
      this.setDims();

      $(window).resize(() => {
        //reset the dimensions on window resize
        this.setDims();
      });
    }

    setDims() {
      this.windowWidth = window.innerWidth;
      this.windowHeight = window.innerHeight;
    }

  }

  const dims = new Dimensions();

  // * ***********************************************************************
  // *
  // *   LAYOUT CLASS
  // *   overall layout set up goes here
  // *
  // *************************************************************************
  class Layout {
    constructor() {

      $(window).resize(() => {

      });
    }
  }

  const layout = new Layout();


  // * ***********************************************************************
  // *
  // *   CANVAS CLASS
  // *
  // *
  // *************************************************************************
  class Canvas {
    constructor() {
      this.draw();
    }

    draw() {
      let p1 = {
        x: 250,
        y: 200
      };
      let p2 = {
        x: 300,
        y: 300
      };
      let mid1 = this.midpoint(p1,p2);
      let m1 = this.perpendicularSlope(p1,p2);

      this.drawPoint(mid1);
      this.drawPoint(p1);
      this.drawPoint(p2);
      this.drawLine(p1,p2, 'red');

      let q1= {
        x: 400,
        y: 400
      };
      let q2 = {
        x: 600,
        y: 300
      };
      let mid2 = this.midpoint(q1,q2);
      let m2 = this.perpendicularSlope(q1,q2);

      this.drawPoint(mid2);
      this.drawPoint(q1);
      this.drawPoint(q2);
      this.drawLine(q1,q2, 'red');

      let c = this.intersection(mid1, m1, mid2, m2);
      this.drawPoint(c);
      this.drawLine(mid1, c, 'green');
      this.drawLine(mid2, c, 'green');
    }

    //intersection point of two lines defined by p1,m1 and q1,m2
    intersection(p1, m1, p2, m2) {
      //y intercept of first line
      let c1 = p1.y-m1*p1.x;
      //y intercept of second line
      let c2 = p2.y-m2*p2.x;

      let x = (c2-c1)/(m1-m2);
      let y = m1*x+c1;
      return {
        x: x,
        y: y
      }
    }

    //draw a point on the disk, optional radius and colour
    drawPoint(point, radius, colour) {
      let c = colour || 'black';
      let r = radius || 2;
      elems.ctx.beginPath();
      elems.ctx.arc(point.x, point.y, r, 0, Math.PI * 2, true);
      elems.ctx.closePath();
      elems.ctx.fillStyle = c;
      elems.ctx.fill();
    }

    drawLine(p1, p2, colour) {
      let c = colour || 'black';
      elems.ctx.beginPath();
      elems.ctx.moveTo(p1.x, p1.y);
      elems.ctx.lineTo(p2.x, p2.y);
      elems.ctx.strokeStyle = c;
      elems.ctx.stroke()
    }

    //midpoint of the line segment connecting two points
    midpoint(p1, p2) {
      return {
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2
      }
    }

    //slope of line through p1, p2
    slope(p1, p2) {
      return (p2.x - p1.x) / (p2.y - p1.y);
    }

    //slope of line perpendicular to a line defined by p1,p2
    perpendicularSlope(p1, p2) {
      return -1/(Math.pow(this.slope(p1, p2), -1));
    }
  }

  const canvas = new Canvas();

});
